/*
 * Copyright (c) 2015 - 2017, Dries007 & Double Door Development
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions via the Curse or CurseForge platform are not allowed without
 *   written prior approval.
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package net.doubledoordev.ctrm;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.common.io.Files;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.Loader;

import net.doubledoordev.ctrm.xml.XmlParser;

/**
 * @author Dries007
 */
@SuppressWarnings("WeakerAccess")
public final class Helper
{
    public static final String MODID = "ctrm";
    public static final String NAME = "MineTweakerRecipeMaker";
    public static final DateFormat DATE_TIME = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");

    public static final String DTD = "/assets/ctrm/mtrm.dtd";

    public static final FileFilter FILE_FILTER_XML = new FileFilter()
    {
        @Override
        public boolean accept(File pathname)
        {
            return pathname.isDirectory() || FilenameUtils.getExtension(pathname.getName()).equalsIgnoreCase("XML");
        }
    };

    private Helper() {}

    public static File getScriptFile() throws IOException
    {
        File file = new File("scripts/", "ctrm.zs");
        Files.createParentDirs(file);
        if (!file.exists())
        {
            Files.touch(file);
            writeHeader(Files.newWriter(file, Charset.defaultCharset()), "<SERVER>").close();
        }
        return file;
    }

    public static BufferedWriter writeHeader(BufferedWriter br, String name) throws IOException
    {
        br.write("// File generated by MineTweakerRecipeMaker (ctrm) by DoubleDoorDevelopment\r\n");
        br.write("// This file is automatically managed by ctrm.\r\n");
        br.write("// Try not to touch it if you don't absolutely have to.\r\n");
        br.write("// If you have too, leave the markers alone. They look like this:\r\n");
        br.write("//\r\n");
        br.write("//    #MTRM MARKER <number here>\r\n");
        br.write("//\r\n");
        br.write("// ================================================================================\r\n");
        br.write("print(\"Loading the MineTweakerRecipeMaker (ctrm) script file.\");");
        br.write("// HERE BE DRAGONS\r\n\r\n");
        return br;
    }

    /**
     * Recursive XML file finder. Always returns the given list.
     *
     * @return the list parameter
     */
    public static List<File> findXMLFiles(File folder, List<File> list)
    {
        if (!folder.isDirectory())
        {
            throw new IllegalArgumentException(folder + " is not a directory.");
        }
        //noinspection ConstantConditions
        for (File file : folder.listFiles(FILE_FILTER_XML))
        {
            if (file.isDirectory())
            {
                findXMLFiles(file, list);
            }
            else
            {
                list.add(file);
            }
        }
        return list;
    }

    public static void makeReadme(File file) throws IOException
    {
        file = new File(file, "README.txt");
        FileUtils.writeLines(file, Arrays.asList(
                "If you want to manually add or edit XML config files, put them in there like they would be in a resourcepack.",
                "This WILL override existing files if they already exist. There will be no version checking!",
                "If you make a useful change, submit it to the original authors, so everyone will benefit.",
                "~Dries007",
                "",
                "EXAMPLES:",
                "You want the edit the default vanilla XML: Put it at 'overrides/ctrm/vanilla.xml'",
                "If you want to add a new XML file, you can put it wherever inside of 'overrides', as long as it has a sub-folder.",
                "",
                "The current MTRM DTD File: (Use this to make sure your XML is correct):",
                ""
        ), "\r\n");
        InputStream is = MineTweakerRecipeMaker.class.getResourceAsStream(DTD);
        FileUtils.writeStringToFile(file, IOUtils.toString(is).replaceAll("\\r?\\n", "\n"), true);
        is.close();
    }

    public static ResourceLocation normalize(ResourceLocation location)
    {
        String path = location.getResourcePath();
        if (path.startsWith("assets/"))
        {
            path = path.substring(path.indexOf('/'));
        }
        if (path.endsWith(".xml") || path.endsWith(".XML"))
        {
            path = path.substring(0, path.lastIndexOf('.'));
        }
        return new ResourceLocation(location.getResourceDomain(), path);
    }

    public static void loadOverrides(List<File> skip) throws Exception
    {
        File modFolder = new File(Loader.instance().getConfigDir(), Helper.MODID);
        if (!modFolder.exists())
        {
            modFolder.mkdirs();
        }
        Helper.makeReadme(modFolder);
        File rootFolder = new File(modFolder, "overrides");
        if (!rootFolder.exists())
        {
            rootFolder.mkdirs();
        }
        Path root = rootFolder.toPath();
        List<File> list = Helper.findXMLFiles(rootFolder, new ArrayList<File>());
        list.removeAll(skip);
        for (File f : list)
        {
            String path = root.relativize(f.toPath()).toString().replaceFirst("\\\\|/", ":");
            XmlParser.addOverrideXml(new ResourceLocation(path), f);
        }
    }

    public static String truncate(String text, int width)
    {
        return text.length() < width ? text : text.substring(0, width) + "...";
    }

    public static String itemstackToString(ItemStack stack)
    {
        if (stack == null)
        {
            return "null";
        }
        StringBuilder sb = new StringBuilder("<");
        sb.append(stack.getItem().getRegistryName());
        int meta = stack.getMetadata();
        if (meta != 0)
        {
            sb.append(meta);
        }
        sb.append('>');
        if (stack.getCount() != 1)
        {
            sb.append('*').append(stack.getCount());
        }
        return sb.toString();
    }

    public static double round(double in, double precision)
    {
        return precision * Math.floor(in / precision);
    }
}
